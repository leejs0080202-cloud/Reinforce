<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Trash Shooter</title>
    <!-- Tailwind CSS for modern, mobile-first styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- onnxruntime-web for AI model inference in the browser -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
    <style>
        body {
            background-color: #e3f2fd;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        canvas {
            touch-action: none;
            cursor: none;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1), 0 6px 6px rgba(0, 0, 0, 0.15);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .game-container {
            position: relative;
            background-color: white;
            padding: 1.5rem;
            border-radius: 2rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }
        .dot-container {
            display: flex;
            gap: 0.5rem;
        }
        .dot {
            width: 0.75rem;
            height: 0.75rem;
            background-color: #3498db;
            border-radius: 50%;
            animation: pulse 1.5s infinite ease-in-out;
        }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 1.5rem 2.5rem;
            background-color: #fcf8e3;
            border: 2px solid #fbeed5;
            border-radius: 1rem;
            color: #8a6d3b;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            text-align: center;
            line-height: 1.5;
            z-index: 10;
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-blue-50">

    <!-- Game UI Container -->
    <div class="game-container">
        <h1 class="text-4xl font-extrabold text-gray-800 text-center mb-4">AI Trash Shooter</h1>
        <div class="flex justify-between items-center px-4 mb-4">
            <span id="score-display" class="text-xl font-bold text-gray-600">Score: 0</span>
            <span id="lives-display" class="text-xl font-bold text-gray-600">Lives: 3</span>
        </div>
        <div id="canvas-wrapper" class="relative">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <!-- Loading indicator overlay -->
            <div id="loading-indicator">
                <div class="dot-container">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
                <span class="text-gray-500 font-medium mt-2">Loading AI Model...</span>
            </div>
            <!-- Message box overlay -->
            <div id="message-box" class="message-box hidden"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const livesDisplay = document.getElementById('lives-display');
        const loadingIndicator = document.getElementById('loading-indicator');
        const messageBox = document.getElementById('message-box');

        // Game Constants
        const SCREEN_WIDTH = 800;
        const SCREEN_HEIGHT = 600;
        const GRAVITY = 0.5;
        const FPS = 60;
        const MS_PER_FRAME = 1000 / FPS;

        // Visual Colors
        const PALETTE = {
            sky: '#D6EAF8',
            ground: '#A2D9CE',
            trashCan: '#4d4f58',
            slingshot: '#6C7A89',
            trash: '#E9EBF1',
            text: '#2C3E50',
            messageBg: '#fffde7',
            messageText: '#5d5d3b',
            impactGlow: '#F5B041'
        };

        // Game Objects
        let score = 0;
        let lives = 3;
        let isGameOver = false;
        let trashCan = {
            x: SCREEN_WIDTH * 0.7, // Position trash can to the right
            y: SCREEN_HEIGHT - 70,
            width: 120,
            height: 15,
            color: PALETTE.trashCan,
            hitCooldown: 0
        };

        let trash = {
            x: 0,
            y: 0,
            radius: 15,
            vx: 0,
            vy: 0,
            isShot: false,
            color: PALETTE.trash,
            hasCollided: false,
            glowAlpha: 0
        };

        let slingshot = {
            x: SCREEN_WIDTH * 0.3, // Position slingshot to the left
            y: SCREEN_HEIGHT - 50,
            pullStrength: 0,
            maxPull: 180
        };

        // AI Model Integration
        let ortSession;
        let modelLoaded = false;
        let lastUpdateTime = 0;

        // Normalization Constants (based on typical environment ranges)
        // These are assumptions and may need fine-tuning to match the training environment
        const NORM_SCREEN_WIDTH = SCREEN_WIDTH;
        const NORM_SCREEN_HEIGHT = SCREEN_HEIGHT;
        const NORM_MAX_VELOCITY = 40;
        const NORM_MAX_ANG_VEL = Math.PI / 10;
        const NORM_MAX_DIST = Math.sqrt(SCREEN_WIDTH * SCREEN_WIDTH + SCREEN_HEIGHT * SCREEN_HEIGHT);
        
        // Actions
        const ACTIONS = {
            AIM_LEFT: 0,
            AIM_RIGHT: 1,
            INCREASE_PULL: 2,
            DECREASE_PULL: 3,
            RELEASE: 4
        };

        // --- Core Game Functions ---
        function resetGame() {
            isGameOver = false;
            score = 0;
            lives = 3;
            updateUI();
            resetTrash();
            trashCan.x = SCREEN_WIDTH * 0.7; // Randomize or keep constant
            messageBox.style.display = 'none';
        }

        function resetTrash() {
            trash.x = slingshot.x;
            trash.y = slingshot.y;
            trash.vx = 0;
            trash.vy = 0;
            trash.isShot = false;
            trash.hasCollided = false;
            trash.glowAlpha = 0;
            slingshot.pullStrength = 0;
        }

        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
        }

        function showMessage(text, isError = false) {
            messageBox.textContent = text;
            messageBox.style.display = 'block';
            if (isError) {
                messageBox.style.backgroundColor = '#f2dede';
                messageBox.style.color = '#a94442';
                messageBox.style.borderColor = '#ebccd1';
            } else {
                messageBox.style.backgroundColor = PALETTE.messageBg;
                messageBox.style.color = PALETTE.messageText;
                messageBox.style.borderColor = '#fbeed5';
            }
        }

        function getObservation() {
            const dx = trashCan.x - trash.x;
            const dy = trashCan.y - trash.y;
            
            // Normalize values
            const norm_pos_x = trash.x / NORM_SCREEN_WIDTH;
            const norm_pos_y = trash.y / NORM_SCREEN_HEIGHT;
            const norm_vel_x = trash.vx / NORM_MAX_VELOCITY;
            const norm_vel_y = trash.vy / NORM_MAX_VELOCITY;
            
            const angle = Math.atan2(dy, dx);
            const norm_angle = (angle + Math.PI) / (2 * Math.PI);

            const ang_vel = (trash.vx * dy - trash.vy * dx) / (dx*dx + dy*dy);
            const norm_ang_vel = ang_vel / NORM_MAX_ANG_VEL;

            const dist = Math.sqrt(dx**2 + dy**2);
            const norm_dist_to_pad = dist / NORM_MAX_DIST;

            // The observation space must exactly match the structure and order
            return new Float32Array([
                norm_pos_x,
                norm_pos_y,
                norm_vel_x,
                norm_vel_y,
                norm_angle,
                norm_ang_vel,
                norm_dist_to_pad
            ]);
        }

        function argMax(array) {
            if (array.length === 0) return -1;
            return array.indexOf(Math.max(...array));
        }

        // --- Drawing Functions ---
        function draw() {
            ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            ctx.fillStyle = PALETTE.sky;
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            ctx.fillStyle = PALETTE.ground;
            ctx.fillRect(0, SCREEN_HEIGHT - 50, SCREEN_WIDTH, 50);

            // Draw slingshot base
            ctx.fillStyle = PALETTE.slingshot;
            ctx.beginPath();
            ctx.arc(slingshot.x, slingshot.y, 25, 0, Math.PI * 2);
            ctx.fill();

            // Draw trash can
            ctx.fillStyle = PALETTE.trashCan;
            ctx.beginPath();
            ctx.roundRect(trashCan.x - trashCan.width / 2, trashCan.y, trashCan.width, trashCan.height, [10, 10, 0, 0]);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(trashCan.x, trashCan.y + 5, 25, 0, Math.PI * 2);
            ctx.fill();

            // Draw trash ball with glowing effect on hit
            if (trash.glowAlpha > 0) {
                ctx.save();
                ctx.shadowBlur = 20;
                ctx.shadowColor = `rgba(245, 176, 65, ${trash.glowAlpha})`;
                ctx.fillStyle = PALETTE.impactGlow;
                ctx.beginPath();
                ctx.arc(trash.x, trash.y, trash.radius + 5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            ctx.fillStyle = trash.color;
            ctx.beginPath();
            ctx.arc(trash.x, trash.y, trash.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw elastic
            if (!trash.isShot) {
                const angle = Math.atan2(trash.y - slingshot.y, trash.x - slingshot.x);
                const dx = Math.cos(angle) * (trash.radius + 5);
                const dy = Math.sin(angle) * (trash.radius + 5);

                ctx.strokeStyle = '#4A4A4A';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(slingshot.x - 10, slingshot.y - 10);
                ctx.lineTo(trash.x + dx, trash.y + dy);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(slingshot.x + 10, slingshot.y - 10);
                ctx.lineTo(trash.x + dx, trash.y + dy);
                ctx.stroke();
            }
        }

        // --- Game Loop ---
        async function gameLoop(timestamp) {
            if (isGameOver) return;
            if (!modelLoaded) {
                draw();
                requestAnimationFrame(gameLoop);
                return;
            }

            const deltaTime = timestamp - lastUpdateTime;
            if (deltaTime < MS_PER_FRAME) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastUpdateTime = timestamp;

            // Handle AI inference if trash is not shot
            if (!trash.isShot) {
                try {
                    const observation = getObservation();
                    const inputTensor = new ort.Tensor('float32', observation, [1, 7]);
                    const results = await ortSession.run({ obs: inputTensor });
                    
                    const output = results.output.data;
                    const action = argMax(output);

                    switch(action) {
                        case ACTIONS.AIM_LEFT:
                            slingshot.x = Math.max(100, slingshot.x - 2);
                            break;
                        case ACTIONS.AIM_RIGHT:
                            slingshot.x = Math.min(SCREEN_WIDTH - 100, slingshot.x + 2);
                            break;
                        case ACTIONS.INCREASE_PULL:
                            slingshot.pullStrength = Math.min(slingshot.maxPull, slingshot.pullStrength + 2);
                            break;
                        case ACTIONS.DECREASE_PULL:
                            slingshot.pullStrength = Math.max(0, slingshot.pullStrength - 2);
                            break;
                        case ACTIONS.RELEASE:
                            const angle = Math.atan2(slingshot.y - trashCan.y, slingshot.x - trashCan.x);
                            const releaseVelocity = slingshot.pullStrength / 20;
                            trash.vx = releaseVelocity * Math.cos(angle);
                            trash.vy = releaseVelocity * Math.sin(angle);
                            trash.isShot = true;
                            break;
                    }
                    trash.x = slingshot.x - Math.cos(angle) * slingshot.pullStrength;
                    trash.y = slingshot.y - Math.sin(angle) * slingshot.pullStrength;
                } catch (e) {
                    console.error("AI Inference failed:", e);
                }
            }

            // Update game state
            if (trash.isShot) {
                trash.vy += GRAVITY;
                trash.x += trash.vx;
                trash.y += trash.vy;
            }

            // Check for collision with the trash can (hit)
            const dx = trash.x - trashCan.x;
            const dy = trash.y - trashCan.y;
            const distToCan = Math.sqrt(dx * dx + dy * dy);
            if (distToCan < trash.radius + trashCan.width/2 && !trash.hasCollided) {
                score += 1;
                updateUI();
                trash.hasCollided = true;
                trash.glowAlpha = 1;
                showMessage("Success!");
                setTimeout(() => resetTrash(), 1500); // Wait for animation
            }
            
            // Animate glow after hit
            if (trash.glowAlpha > 0) {
                trash.glowAlpha -= 0.05;
                if (trash.glowAlpha < 0) trash.glowAlpha = 0;
            }

            // Check if trash is out of bounds
            if (trash.y > SCREEN_HEIGHT + 50 || trash.x < -50 || trash.x > SCREEN_WIDTH + 50) {
                if (!trash.hasCollided) {
                    lives -= 1;
                    updateUI();
                    showMessage("Miss!");
                }
                resetTrash();

                if (lives <= 0) {
                    isGameOver = true;
                    showMessage("Game Over! Final Score: " + score);
                }
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Initialization ---
        async function init() {
            canvas.width = SCREEN_WIDTH;
            canvas.height = SCREEN_HEIGHT;

            // Load ONNX model
            try {
                // The input name 'obs' and output name 'output' are based on common ONNX conventions.
                // If the model uses different names, this will need to be adjusted.
                ortSession = await ort.InferenceSession.create('model.onnx');
                modelLoaded = true;
                loadingIndicator.style.display = 'none';
                resetGame();
                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error("Failed to load ONNX model:", e);
                loadingIndicator.innerHTML = '<span class="text-red-500 font-bold">Error loading model. Check console.</span>';
            }
        }

        window.onload = init;
    </script>
</body>
</html>
